<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Saravanan Hari Baskaran</title>
    <link href="/dist/output.css" rel="stylesheet" />
    <link
      href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/swiper@10/swiper-bundle.min.css"
    />
    <style>
      /* Existing animations */
      /* Custom animations */
      .persuasive-text {
        background: linear-gradient(45deg, #5dadec, #ffffff);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        animation: gradientFlow 3s ease infinite;
      }

      @keyframes gradientFlow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }

      /* Neon flickering effect for name */
      .neon-flicker {
        color: #fff;
        text-shadow: 
          0 0 5px #fff,
          0 0 10px #fff,
          0 0 20px #5dadec,
          0 0 30px #5dadec,
          0 0 40px #5dadec,
          0 0 55px #5dadec;
        animation: flicker 2s infinite alternate;
      }

      @keyframes flicker {
        0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
          text-shadow: 
            0 0 5px #fff,
            0 0 10px #fff,
            0 0 20px #5dadec,
            0 0 30px #5dadec,
            0 0 40px #5dadec,
            0 0 55px #5dadec;
        }
        20%, 24%, 55% {
          text-shadow: none;
        }
      }

      /* Glassy neon strips */
      .neon-strip {
        position: fixed;
        top: 0;
        width: 4px;
        height: 100vh;
        background: rgba(93, 173, 236, 0.3);
        backdrop-filter: blur(5px);
        box-shadow: 
          0 0 5px #5dadec,
          0 0 10px #5dadec,
          0 0 20px #5dadec;
        z-index: 1000;
      }

      .neon-strip-left {
        left: 0;
      }

      .neon-strip-right {
        right: 0;
      }

      /* Glassy container effect */
      .glass-container {
        background: rgba(255, 255, 255, 0.03);
        backdrop-filter: blur(10px);
        border: none;
        box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2);
      }

      /* Add glassy effect to existing elements */
      .border-primary {
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(93, 173, 236, 0.3);
        box-shadow: 
          0 0 10px rgba(93, 173, 236, 0.2),
          0 0 20px rgba(93, 173, 236, 0.1);
      }

      /* Work Experience Animations */
      .timeline-item {
        opacity: 0;
        transform: translateY(30px);
        transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .timeline-item.visible {
        opacity: 1;
        transform: translateY(0);
      }

      .timeline-item:nth-child(odd) {
        transform: translateX(-30px);
      }

      .timeline-item:nth-child(even) {
        transform: translateX(30px);
      }

      .timeline-item.visible:nth-child(odd),
      .timeline-item.visible:nth-child(even) {
        transform: translateX(0);
      }

      .timeline-content {
        background: rgba(255, 255, 255, 0.03);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 1.25rem;
        transition: all 0.3s ease;
      }

      .timeline-content:hover {
        transform: translateY(-5px);
        box-shadow: 0 0 20px rgba(93, 173, 236, 0.2);
      }

      /* Flicker animation for content below */
      .flicker-content {
        opacity: 0;
        animation: contentFlicker 0.5s ease-in forwards;
        animation-delay: 0.3s;
      }

      @keyframes contentFlicker {
        0% { opacity: 0; }
        20% { opacity: 0.2; }
        40% { opacity: 0; }
        60% { opacity: 0.4; }
        80% { opacity: 0.1; }
        100% { opacity: 1; }
      }

      .glossy-blue-shadow {
        color: #fff;
        text-shadow:
          0 0 8px #5dadec,
          0 0 16px #5dadec,
          0 0 24px #5dadec;
        position: relative;
      }
      .glossy-blue-shadow::after {
        content: '';
        position: absolute;
        left: 50%;
        top: 30%;
        transform: translateX(-50%);
        width: 60%;
        height: 35%;
        background: linear-gradient(120deg, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0.1) 100%);
        border-radius: 50%;
        pointer-events: none;
        filter: blur(2px);
        opacity: 0.7;
      }

      /* Scroll-Driven Animations */
      .fade-in {
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.6s ease-out;
      }

      .fade-in.visible {
        opacity: 1;
        transform: translateY(0);
      }

      .slide-in-left {
        opacity: 0;
        transform: translateX(-50px);
        transition: all 0.6s ease-out;
      }

      .slide-in-left.visible {
        opacity: 1;
        transform: translateX(0);
      }

      .slide-in-right {
        opacity: 0;
        transform: translateX(50px);
        transition: all 0.6s ease-out;
      }

      .slide-in-right.visible {
        opacity: 1;
        transform: translateX(0);
      }

      .scale-in {
        opacity: 0;
        transform: scale(0.8);
        transition: all 0.6s ease-out;
      }

      .scale-in.visible {
        opacity: 1;
        transform: scale(1);
      }

      .rotate-in {
        opacity: 0;
        transform: rotate(-10deg) scale(0.8);
        transition: all 0.6s ease-out;
      }

      .rotate-in.visible {
        opacity: 1;
        transform: rotate(0) scale(1);
      }

      /* 3D Card Effect */
      .project-card {
        transform-style: preserve-3d;
        perspective: 1000px;
        transition: transform 0.5s ease;
      }

      .project-card:hover {
        transform: translateY(-10px) rotateX(5deg) rotateY(5deg);
      }

      .project-card::before {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(45deg, transparent, rgba(93, 173, 236, 0.1));
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .project-card:hover::before {
        opacity: 1;
      }

      /* Add these new styles for the neural network background */
      #heroCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        opacity: 0.3;
        transition: opacity 0.5s ease;
        pointer-events: all;
        touch-action: none;
      }
      #heroCanvas:hover {
        opacity: 0.6;
      }
      .hero-content {
        position: relative;
        z-index: 10;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 2rem;
        pointer-events: none;
      }
      .hero-content * {
        pointer-events: auto;
      }
      @keyframes nodePulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
      }
      .hidden-section {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.7s;
      }
      .fade-in-section {
        opacity: 1 !important;
        pointer-events: auto !important;
        transition: opacity 0.7s;
      }
      /* Add typing cursor animation */
      .typing-cursor {
        display: inline-block;
        width: 2px;
        height: 1em;
        background-color: #5dadec;
        margin-left: 2px;
        animation: blink 1s step-end infinite;
        vertical-align: middle;
      }

      @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
      }

      .typing-text {
        display: inline-block;
        position: relative;
      }

      .typing-text::after {
        content: '|';
        position: absolute;
        right: -2px;
        color: #5dadec;
        animation: blink 1s step-end infinite;
      }

      .timeline-arrow {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        z-index: 20;
        pointer-events: none;
      }
      .timeline-item {
        z-index: 30;
      }
      .timeline-arrow-auto {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 64px;
        margin: -16px 0 16px 0;
        position: relative;
        z-index: 20;
      }
      .timeline-arrow-auto svg {
        width: 64px;
        height: 64px;
      }
      .timeline-arrow-auto::before,
      .timeline-arrow-auto::after {
        content: '';
        display: block;
        width: 6px;
        height: 24px;
        background: #5dadec;
        margin: 0 auto;
      }
      .timeline-arrow-auto::before {
        margin-bottom: 4px;
      }
      .timeline-arrow-auto::after {
        margin-top: 4px;
      }
      .__item-left {
        left: 0;
      }
      .__item-right {
        left: 80px;
      }
      @media (max-width: 900px) {
        .__item-left, .__item-right {
          left: 0 !important;
        }
      }
      .card-component {
        transform-style: preserve-3d;
        perspective: 1000px;
        transition: transform 0.5s cubic-bezier(0.4,0,0.2,1);
        padding: 1.2em 1.5em;
        max-width: 500px;
        font-family: Arial, sans-serif;
        position: relative;
      }
      .card-component:hover {
        transform: translateY(-10px) rotateX(5deg) rotateY(5deg);
      }
    </style>
    <!-- three.js core -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <!-- typed.js for rotating text -->
    <script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12"></script>

  </head>
  <body class="bg-background overflow-x-hidden">
    <!-- Neon strips -->
    <div class="neon-strip neon-strip-left"></div>
    <div class="neon-strip neon-strip-right"></div>

    <!-- Custom cursor -->
    <div class="custom-cursor"></div>

    <!-- header -->
    <header
      class="fixed top-0 right-0 left-0 md:py-1 transition-all duration-300 glass-container fade-in"
      data-aos="fade-down"
    >
      <nav
        class="max-w-7xl mx-auto bg-gray-800 md:bg-transparent p-5 order-[10001]"
      >
        <div class="flex items-center justify-between">
          <a
            href="/"
            class="text-white font-bold text-lg flex items-center gap-3"
            ><img src="src/img/Logo.svg" alt="" class="w-8 h-8" /> Saravanan
            Hari Baskaran</a
          >
          <!-- only for large device -->
          <div class="hidden md:flex space-x-10">
            <a href="#home" class="text-primary hover:text-gray-300">Home</a>
            <a href="#projects" class="text-white hover:text-gray-300"
              >Projects</a
            >
            <a href="#resume" class="text-white hover:text-gray-300">Resume</a>
          </div>
          <!-- menu btn, only disply on mobile -->
          <div class="md:hidden">
            <button id="mobile-menu-button" class="text-white text-2xl">
              <i class="bx bx-menu"></i>
            </button>
          </div>
        </div>

        <!-- mobile menu -->
        <div id="mobile-menu" class="hidden md:hidden">
          <a href="#home" class="block text-white py-2 mt-3 hover:bg-gray-700"
            >Home</a
          >
          <a href="#projects" class="block text-white py-2 hover:bg-gray-700"
            >Projects</a
          >
          <a href="#resume" class="block text-white py-2 hover:bg-gray-700"
            >Resume</a
          >
        </div>
      </nav>
    </header>

    <!-- banner section -->
    <!-- Hero Section with Neural Network Background -->
    <section id="home" class="relative w-full overflow-hidden">
      <!-- Three.js canvas for neural network visualization -->
      <canvas id="heroCanvas"></canvas>
      <div class="hero-content">
        <h1 class="text-10xl sm:text-10xl font-bold" style="font-size:32px;color:white">
          <span id="name-typing"></span>
        </h1>
        <div id="subtitle" class="mt-4 text-2xl persuasive-text"></div>
        <div class="mt-8 flicker-content">
          <p class="text-white max-w-2xl text-center">
            <span id="description-typing"></span>
          </p>
        </div>
      </div>
    </section>

    <script>
    // ——— Setup scene/camera/renderer exactly as before ———
    const canvas    = document.getElementById('heroCanvas');
    const scene     = new THREE.Scene();
    
    // Replace perspective camera with orthographic camera
    const aspect = window.innerWidth / window.innerHeight;
    const frustumSize = 20;
    const camera = new THREE.OrthographicCamera(
      frustumSize * aspect / -2,
      frustumSize * aspect / 2,
      frustumSize / 2,
      frustumSize / -2,
      0.1,
      1000
    );
    const renderer  = new THREE.WebGLRenderer({ 
      canvas, 
      alpha: true, 
      antialias: true 
    });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Add this function to check for nearby nodes
    function isNearExistingNode(pos) {
      const minDistance = 0.8; // Reduced for more precise layer placement
      return nodes.some(node => node.position.distanceTo(pos) < minDistance);
    }
    
    // Enhanced lighting setup
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    const pointLight1 = new THREE.PointLight(0xffffff, 1, 100);
    pointLight1.position.set(-5, 5, 5);
    scene.add(pointLight1);

    const pointLight2 = new THREE.PointLight(0xffffff, 1, 100);
    pointLight2.position.set(5, -5, 5);
    scene.add(pointLight2);
    
    // storage
    const nodes = [];
    const edges = [];
    let drawing = false, start = null, previewLine = null;
    
    // Function to create structured neural network
    function createRandomNetwork() {
      const numLayers = 6;
      const nodesPerLayer = [4, 6, 7, 7, 6, 5]; // Number of nodes in each layer
      const layerSpacing = 5; // Horizontal spacing between layers
      const nodeSpacing = 2; // Vertical spacing between nodes
      
      // Calculate total width and starting x position
      const totalWidth = (numLayers - 1) * layerSpacing;
      const startX = -totalWidth / 2;
      
      // Create nodes in layers
      for (let layer = 0; layer < numLayers; layer++) {
        const x = startX + layer * layerSpacing;
        const numNodes = nodesPerLayer[layer];
        const totalHeight = (numNodes - 1) * nodeSpacing;
        const startY = totalHeight / 2;
        
        for (let i = 0; i < numNodes; i++) {
          const y = startY - i * nodeSpacing;
          const node = new THREE.Mesh(nodeGeo, nodeMat.clone());
          node.position.set(x, y, 0);
          node.castShadow = true;
          node.receiveShadow = true;
          // Store original position and assign random phase/amplitude for floating
          node.userData.originalPosition = { x, y, z: 0 };
          node.userData.floatPhase = Math.random() * Math.PI * 2;
          node.userData.floatAmpX = 0.15 + Math.random() * 0.12;
          node.userData.floatAmpY = 0.15 + Math.random() * 0.12;
          nodes.push(node);
          scene.add(node);
        }
      }
      
      // Create connections
      for (let layer = 0; layer < numLayers - 1; layer++) {
        const currentLayerNodes = nodes.filter(n => 
          Math.abs(n.position.x - (startX + layer * layerSpacing)) < 0.1
        );
        const nextLayerNodes = nodes.filter(n => 
          Math.abs(n.position.x - (startX + (layer + 1) * layerSpacing)) < 0.1
        );
        
        // Create main forward connections
        currentLayerNodes.forEach(node1 => {
          nextLayerNodes.forEach(node2 => {
            // 70% chance to create a connection
            if (Math.random() < 0.7) {
              const geom = new THREE.BufferGeometry().setFromPoints([
                node1.position,
                node2.position
              ]);
              const line = new THREE.Line(geom, edgeMat.clone());
              scene.add(line);
              edges.push({ line, a: node1, b: node2 });
            }
          });
        });
        
        // Add some cross-layer connections (skip one layer)
        if (layer < numLayers - 2) {
          const skipLayerNodes = nodes.filter(n => 
            Math.abs(n.position.x - (startX + (layer + 2) * layerSpacing)) < 0.1
          );
          
          currentLayerNodes.forEach(node1 => {
            skipLayerNodes.forEach(node2 => {
              // 20% chance to create a skip connection
              if (Math.random() < 0.2) {
                const geom = new THREE.BufferGeometry().setFromPoints([
                  node1.position,
                  node2.position
                ]);
                const line = new THREE.Line(geom, edgeMat.clone());
                scene.add(line);
                edges.push({ line, a: node1, b: node2 });
              }
            });
          });
        }
      }
    }

    // geometries & materials
    const nodeGeo = new THREE.SphereGeometry(0.25, 64, 64);
    const nodeMat = new THREE.MeshPhongMaterial({ 
      color: 0xffffff,
      transparent: true,
      opacity: 0.95,
      shininess: 30,
      specular: 0xffffff,
      emissive: 0xffffff,
      emissiveIntensity: 0.2
    });
    const edgeMat = new THREE.LineBasicMaterial({ 
      color: 0xffffff, 
      linewidth: 2,
      transparent: true,
      opacity: 0.7
    });
    const previewMat = new THREE.LineDashedMaterial({ 
      color: 0xffffff, 
      dashSize: 0.15, 
      gapSize: 0.1, 
      linewidth: 2,
      transparent: true,
      opacity: 0.5
    });

    // Create initial network after materials are defined
    createRandomNetwork();

    // Assign a random phase to each node and edge for organic pulsing
    globalThis._pulsePhases = globalThis._pulsePhases || { nodes: new WeakMap(), edges: new WeakMap() };

    function animateNodes() {
      const t = performance.now() * 0.001;
      nodes.forEach(node => {
        node.rotation.x += 0.005;
        node.rotation.y += 0.005;
        // Pulsing glow
        let phase = globalThis._pulsePhases.nodes.get(node);
        if (phase === undefined) {
          phase = Math.random() * Math.PI * 2;
          globalThis._pulsePhases.nodes.set(node, phase);
        }
        const intensity = 0.18 + 0.12 * Math.abs(Math.sin(t * 2 + phase));
        if (node.material.emissiveIntensity !== undefined) {
          node.material.emissiveIntensity = intensity;
        }
        // Floating/swaying effect
        if (node.userData.originalPosition) {
          const { x, y, z } = node.userData.originalPosition;
          const floatPhase = node.userData.floatPhase;
          const ampX = node.userData.floatAmpX;
          const ampY = node.userData.floatAmpY;
          node.position.x = x + Math.sin(t + floatPhase) * ampX;
          node.position.y = y + Math.cos(t * 0.8 + floatPhase) * ampY;
          // (z remains unchanged)
        }
      });
      edges.forEach(edge => {
        let phase = globalThis._pulsePhases.edges.get(edge);
        if (phase === undefined) {
          phase = Math.random() * Math.PI * 2;
          globalThis._pulsePhases.edges.set(edge, phase);
        }
        const opacity = 0.5 + 0.2 * Math.abs(Math.sin(t * 2 + phase));
        if (edge.line.material.opacity !== undefined) {
          edge.line.material.opacity = opacity;
          edge.line.material.needsUpdate = true;
        }
        // Update edge geometry to follow floating nodes
        if (edge.a && edge.b && edge.line.geometry) {
          edge.line.geometry.setFromPoints([
            edge.a.position,
            edge.b.position
          ]);
          edge.line.geometry.attributes.position.needsUpdate = true;
        }
      });
    }

    // Add particle system for explosions
    const particleGeometry = new THREE.SphereGeometry(0.04, 10, 10); // Larger, visible dust particles
    const particleMaterial = new THREE.MeshPhongMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.5, // Still somewhat transparent
      emissive: 0xffffff,
      emissiveIntensity: 0.4
    });

    // Particle system constants
    const PARTICLE_COUNT = 100;  // Lots of particles for full coverage
    const EXPLOSION_RADIUS = 7;  // Very large explosion radius
    const EXPLOSION_SPEED = 0.18;  // Fast enough to reach screen edges
    const GRAVITY = 0.002;  // Gentle gravity
    const MIN_DECAY = 0.001;  // Slow fade out
    const MAX_DECAY = 0.003;
    const PARTICLE_SCALE = 1.5;  // Particles grow a bit

    // Store particles
    const particles = [];

    function createExplosion(position) {
      const particles = [];
      
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
        
        // Random position within a sphere
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const r = Math.random() * EXPLOSION_RADIUS;
        
        particle.position.copy(position);
        particle.velocity = new THREE.Vector3(
          r * Math.sin(phi) * Math.cos(theta),
          r * Math.sin(phi) * Math.sin(theta),
          r * Math.cos(phi)
        ).multiplyScalar(EXPLOSION_SPEED);
        
        // Add some random rotation
        particle.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
        
        particle.userData.life = 1.0;
        particle.userData.decay = MIN_DECAY + Math.random() * (MAX_DECAY - MIN_DECAY);
        particle.userData.initialScale = 1;
        particle.userData.targetScale = PARTICLE_SCALE;
        
        scene.add(particle);
        particles.push(particle);
      }

      return particles;
    }

    // Update animate function to include particle animation
    (function animate() {
      requestAnimationFrame(animate);
      animateNodes();
      
      // Animate particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        particle.position.add(particle.velocity);
        particle.velocity.y -= GRAVITY;
        
        // Rotate particles
        particle.rotation.x += 0.05;
        particle.rotation.y += 0.05;
        
        // Scale up particles
        const scale = particle.userData.initialScale + 
          (particle.userData.targetScale - particle.userData.initialScale) * 
          (1 - particle.userData.life);
        particle.scale.set(scale, scale, scale);
        
        particle.userData.life -= particle.userData.decay;
        particle.material.opacity = particle.userData.life * 0.4; // Fade out gently, max opacity 0.4
        
        if (particle.userData.life <= 0) {
          scene.remove(particle);
          particles.splice(i, 1);
        }
      }
      
      renderer.render(scene, camera);
    })();

    // Update double-click handler
    canvas.addEventListener('dblclick', e => {
      updatePointer(e);
      const hit = getNode();
      if (!hit) return;
      
      // Create explosion at node position
      const explosionParticles = createExplosion(hit.position);
      particles.push(...explosionParticles);
      
      // remove all edges involving it
      edges.filter(c => c.a === hit || c.b === hit)
           .forEach(c => scene.remove(c.line));
      // purge from array
      for (let i = edges.length - 1; i >= 0; i--) {
        if (edges[i].a === hit || edges[i].b === hit) edges.splice(i, 1);
      }
      // remove node
      scene.remove(hit);
      nodes.splice(nodes.indexOf(hit), 1);
    });

    // Update render loop to include node animation
    (function animate(){
      requestAnimationFrame(animate);
      animateNodes();
      renderer.render(scene, camera);
    })();
    
    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const width = window.innerWidth;
      const height = window.innerHeight;
      
      // Set canvas size with device pixel ratio
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      
      // Set display size
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      
      // Update renderer and camera
      renderer.setSize(width, height, false);
      renderer.setPixelRatio(dpr);
      
      // Update orthographic camera
      const aspect = width / height;
      const frustumSize = 20;
      camera.left = -frustumSize * aspect / 2;
      camera.right = frustumSize * aspect / 2;
      camera.top = frustumSize / 2;
      camera.bottom = -frustumSize / 2;
      camera.updateProjectionMatrix();
      
      // Set camera position
      camera.position.z = 10;
    }
    
    // Initial setup
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // raycaster + pointer
    const raycaster = new THREE.Raycaster();
    const pointer   = new THREE.Vector2();
    
    // convert screen event → NDC
    function updatePointer(e){
      const rect = canvas.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    }
    // find node under pointer
    function getNode(){
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(nodes);
      return hits[0]?.object || null;
    }
    // Helper: get pointer world position on z=0 plane
    function getPointerWorldPosition() {
      raycaster.setFromCamera(pointer, camera);
      const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // z=0 plane
      const pos = new THREE.Vector3();
      raycaster.ray.intersectPlane(planeZ, pos);
      return pos;
    }
    // ——— CLICK: add node or begin edge ———
    canvas.addEventListener('pointerdown', e=>{
      updatePointer(e);
      const hit = getNode();
      if (hit) {
        // mousedown on node: start drawing edge
        drawing = true;
        start   = hit;
        // preview line
        const geom = new THREE.BufferGeometry().setFromPoints([ start.position, start.position ]);
        previewLine = new THREE.Line(geom, previewMat);
        previewLine.computeLineDistances();
        scene.add(previewLine);
      } else {
        // empty space: spawn at z=0 plane
        const pos = getPointerWorldPosition();
        if (!getNode() && !isNearExistingNode(pos)) {
          const node = new THREE.Mesh(nodeGeo, nodeMat.clone());
          node.position.copy(pos);
          node.castShadow = true;
          node.receiveShadow = true;
          // Assign floating and pulsing properties
          node.userData.originalPosition = { x: pos.x, y: pos.y, z: pos.z };
          node.userData.floatPhase = Math.random() * Math.PI * 2;
          node.userData.floatAmpX = 0.15 + Math.random() * 0.12;
          node.userData.floatAmpY = 0.15 + Math.random() * 0.12;
          if (globalThis._pulsePhases && globalThis._pulsePhases.nodes) {
            globalThis._pulsePhases.nodes.set(node, Math.random() * Math.PI * 2);
          }
          scene.add(node);
          nodes.push(node);
        } else {
        }
      }
    });
    // ——— MOVE: update preview line ———
    canvas.addEventListener('pointermove', e=>{
      if (!drawing) return;
      updatePointer(e);
      const endPos = getPointerWorldPosition();
      previewLine.geometry.setFromPoints([ start.position, endPos ]);
      previewLine.computeLineDistances();
      previewLine.geometry.attributes.position.needsUpdate = true;
    });
    // ——— UP: finalize edge if over another node ———
    canvas.addEventListener('pointerup', e=>{
      if (!drawing) return;
      updatePointer(e);
      const hit = getNode();
      if (hit && hit !== start) {
        const geom = new THREE.BufferGeometry().setFromPoints([ start.position, hit.position ]);
        const line = new THREE.Line(geom, edgeMat.clone());
        scene.add(line);
        const edgeObj = { line, a:start, b:hit };
        edges.push(edgeObj);
        // Assign pulsing phase for new edge
        if (globalThis._pulsePhases && globalThis._pulsePhases.edges) {
          globalThis._pulsePhases.edges.set(edgeObj, Math.random() * Math.PI * 2);
        }
      }
      // cleanup preview
      scene.remove(previewLine);
      previewLine = null;
      drawing     = false;
      start       = null;
    });
    // Add hover effect to nodes
    canvas.addEventListener('pointermove', e => {
      updatePointer(e);
      const hit = getNode();
      nodes.forEach(node => {
        const mat = node.material;
        if (node === hit) {
          mat.color.set('#5dadec'); // blue
        } else {
          mat.color.set('#ffffff'); // white
        }
      });
      edges.forEach(edge => {
        if (edge.a === hit || edge.b === hit) {
          edge.line.material.color.set('#5dadec'); // blue
        } else {
          edge.line.material.color.set('#ffffff'); // white
        }
      });
    });
    canvas.addEventListener('pointerout', () => {
      nodes.forEach(node => node.material.color.set('#ffffff'));
      edges.forEach(edge => edge.line.material.color.set('#ffffff'));
    });
    // Ensure hero section is below the fixed header
    function fitHeroBelowHeader() {
      const header = document.querySelector('header');
      const hero = document.getElementById('home');
      if (!header || !hero) return;
      const h = header.getBoundingClientRect().height;
      hero.style.paddingTop = h + 'px';
      hero.style.height = `calc(100vh - ${h}px)`;
    }
    window.addEventListener('DOMContentLoaded', fitHeroBelowHeader);
    window.addEventListener('resize', fitHeroBelowHeader);
    </script>

    <!-- service section -->
    <section class="max-w-7xl mx-auto px-5 my-6 text-white hidden-section" id="Timeline">
      <div class="text-center rotate-in">
        <h3 class="text-3xl font-bold mb-5">
          <span id="work-typing"></span>
        </h3>
      </div>
      <div style="position: relative; min-height: 1200px;">
        <ul class="list-component" style="position:relative; z-index:1;">
          <li class="__item __item-center">
            <div class="card-component glass-container border border-primary rounded-2xl p-5 shadow-xl">
              <h2 class="__year">Apr 2020 - May 2020</h2>
              <h1 class="__title">Data Science Intern, Verzeo EduTech</h1>
              <p class="__text">Remote</p>
              <ul>
                <li>Built a high-accuracy student performance prediction pipeline by honing Random Forest, XGBoost, and LightGBM models with k-fold cross-validation and hyperparameter tuning, achieving R² = 0.93 for forecasting outcomes such as course completion and engagement levels.</li>
                <li>Streamlined adaptive data preprocessing with IQR-based outlier removal, dynamic encoding, and missing value imputation to handle noisy LMS and enrollment data; led data quality initiatives using NumPy, SciPy, and Pandas to enforce statistical validation, bolstering model reliability across diverse student segments.</li>
              </ul>
            </div>
          </li>
          <li class="__item __item-center">
            <div class="card-component glass-container border border-primary rounded-2xl p-5 shadow-xl">
              <h2 class="__year">Jan 2022 - May 2024</h2>
              <h1 class="__title">Data Scientist, MakeMyTrip India Private Limited</h1>
              <p class="__text">Bengaluru, Karnataka, India</p>
              <ul>
                <li>Benchmarked sentiment models including BERT, TF-IDF with Logistic Regression, and RoBERTa, and worked collaboratively to finalize DistilBERT for its performance–efficiency balance while helping develop an internal NLP engine revealing complaint themes and sentiment trends in hotel reviews.</li>
                <li>Took initiative to redesign tax document OCR pipeline combining advanced image pre-processing (adaptive thresholding, skew correction) with a fine-tuned CRNN model and LSTM-enhanced Tesseract, increasing invoice data extraction accuracy from 57% to 83.33% across highly unstructured document formats.</li>
                <li>Drove development of end-to-end deep learning–powered photo moderation pipeline to flag low-quality, policy-violating, or misleading hotel listing images by integrating ResNet50 for content quality classification, OCR for text overlay detection, perceptual hashing for duplicate identification, and rule-based filters for category mismatches lessening manual review effort by ~40% and improving listing integrity.</li>
              </ul>
            </div>
          </li>
          <li class="__item __item-center">
            <div class="card-component glass-container border border-primary rounded-2xl p-5 shadow-xl">
              <h2 class="__year">Jan 2022 - May 2022</h2>
              <h1 class="__title">Software Engineer Intern, MakeMyTrip India Pvt Ltd</h1>
              <p class="__text">Bengaluru, Karnataka, India</p>
              <ul>
                <li>Improved invoice OCR feature accuracy from 57% to 83.33%.</li>
                <li>Collaborated with cross-functional teams to address system vulnerabilities and reduce critical bugs by 32.</li>
              </ul>
            </div>
          </li>
          <li class="__item __item-center">
            <div class="card-component glass-container border border-primary rounded-2xl p-5 shadow-xl">
              <h2 class="__year">Jun 2022 - May 2024</h2>
              <h1 class="__title">Software Engineer, MakeMyTrip India Pvt Ltd</h1>
              <p class="__text">Bengaluru, Karnataka, India</p>
              <ul>
                <li>Led development of key features for hotel management system.</li>
                <li>Developed auto GSTN validation system, reducing daily work hours by four person-days.</li>
                <li>Refactored code and improved system performance by 20%.</li>
              </ul>
            </div>
          </li>
          <li class="__item __item-center">
            <div class="card-component glass-container border border-primary rounded-2xl p-5 shadow-xl">
              <h2 class="__year">May 2025 - Present</h2>
              <h1 class="__title">Machine Learning Engineer Intern, Arklex.AI</h1>
              <p class="__text">New York, New York, US</p>
              <ul>
                <li>Took the lead in architecting a modular LLM-powered agentic framework with Retrieval-Augmented Generation (RAG) support, enabling context-grounded response generation using enterprise-specific data sources.</li>
                <li>Led development of real-time configurable agent personas, including dynamic tone modulation, sentence complexity, and behavioral rules, allowing deployment of adaptive, brand-aligned AI agents tailored to user context and intent.</li>
              </ul>
            </div>
          </li>
        </ul>
      </div>
      <style>
        .list-component {
          border-left: none;
          list-style: none;
          margin-left: 0;
          padding-top: 20px;
          padding-bottom: 20px;
          position: relative;
        }
        .list-component .__item {
          padding: 0 0 24px 0;
          margin-left: 0;
          position: relative;
          margin-bottom: 0;
          display: flex;
          justify-content: center;
        }
        .__item-center {
          left: 0;
          justify-content: center;
        }
        .timeline-arrow-auto {
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          height: 64px;
          margin: -16px 0 16px 0;
          position: relative;
          z-index: 20;
        }
        .timeline-arrow-auto svg {
          width: 64px;
          height: 64px;
        }
        .timeline-arrow-auto::before,
        .timeline-arrow-auto::after {
          content: '';
          display: block;
          width: 6px;
          height: 24px;
          background: #5dadec;
          margin: 0 auto;
        }
        .timeline-arrow-auto::before {
          margin-bottom: 4px;
        }
        .timeline-arrow-auto::after {
          margin-top: 4px;
        }
        .card-component {
          padding: 1.2em 1.5em;
          max-width: 500px;
          font-family: Arial, sans-serif;
          position: relative;
        }
        .card-component .__year {
          color: #5dadec;
          font-weight: bold;
          margin-bottom: 0.2em;
        }
        .card-component .__title {
          font-size: 1.1em;
          font-weight: bold;
          margin-bottom: 0.2em;
        }
        .card-component .__text {
          color: #b0b8c1;
          font-size: 0.98em;
        }
      </style>
      <script>
      // Automatically insert arrows between every pair of timeline items
      document.addEventListener('DOMContentLoaded', function() {
        const container = document.querySelector('.list-component');
        if (!container) return;
        // Get all timeline items
        const items = Array.from(container.querySelectorAll('.__item'));
        // Remove any old arrows
        container.querySelectorAll('.timeline-arrow-auto').forEach(el => el.remove());
        // Insert arrows between items
        for (let i = items.length - 1; i > 0; i--) {
          const arrowDiv = document.createElement('div');
          arrowDiv.className = 'timeline-arrow-auto';
          arrowDiv.innerHTML = `
            <svg viewBox="0 0 80 80" width="64" height="64">
              <polygon points="20,20 40,60 60,20" fill="#5dadec" opacity="0.85"/>
            </svg>
          `;
          container.insertBefore(arrowDiv, items[i]);
        }
      });
      </script>
    </section>
    
    

    <!-- projects -->
    <section class="px-5 my-32 mx-auto max-w-7xl hidden-section" id="projects">
      <div class="text-center text-white glass-container p-8 rounded-lg scale-in">
        <h3 class="text-3xl font-bold mb-5">
          Recent <span class="text-primary">Projects</span>
        </h3>
        <p class="mb-6 md:w-3/4 mx-auto">
          Merging technical expertise with creativity, I have delivered
          impactful solutions that streamline operations, enhance user
          experience, and drive innovation. Here are some of my highlights:
        </p>
      </div>
      <div
        class="flex flex-col md:flex-row items-center justify-between gap-8 my-20"
      >
        <!-- Project 1 -->
        <div
          class="border border-primary shadow-xl shadow-[#5dadec3b] w-full md:w-[48%] rounded-2xl p-5 project-card slide-in-left"
        >
          <img
            src="src/img/scalable-data-platform.svg"
            alt="Scalable Data Platform"
            class="p-5 w-full h-[300px]"
          />
          <h4 class="text-xl font-bold text-primary mb-2">
            Scalable Data Platform on AWS
          </h4>
          <p class="text-white text-sm">
            Built a data pipeline with Apache Spark on AWS, processing 10M+
            records with 70% faster analytics, and integrated ML models with
            93.8% accuracy for real-time predictions.
          </p>
        </div>
        <!-- Project 2 -->
        <div
          class="border border-primary shadow-xl shadow-[#5dadec3b] w-full md:w-[48%] rounded-2xl p-5 project-card slide-in-right"
        >
          <img
            src="src/img/pustak.svg"
            alt="Pustak Project"
            class="p-5 w-full h-[300px]"
          />
          <h4 class="text-xl font-bold text-primary mb-2">
            Pustak – Book Management Platform
          </h4>
          <p class="text-white text-sm">
            Developed a Django-powered app for book exchange, integrating
            BeautifulSoup for web scraping and deploying on Heroku with robust
            user authentication and APIs.
          </p>
        </div>
      </div>
      <div
        class="flex flex-col md:flex-row items-center justify-between gap-8 my-20"
      >
        <!-- Project 3 -->
        <div
          class="border border-primary shadow-xl shadow-[#5dadec3b] w-full md:w-[48%] rounded-2xl p-5 project-card slide-in-left"
        >
          <img
            src="src/img/hotel-management.svg"
            alt="Hotel Management"
            class="p-5 w-full h-[300px]"
          />
          <h4 class="text-xl font-bold text-primary mb-2">
            Hotel Management System – MakeMyTrip
          </h4>
          <p class="text-white text-sm">
            Spearheaded fraud prevention and compliance features, while
            designing a GSTN validation system with Kafka and Redis, reducing
            workload by 4 person-days daily.
          </p>
        </div>
        <!-- Project 4 -->
        <div
          class="border border-primary shadow-xl shadow-[#5dadec3b] w-full md:w-[48%] rounded-2xl p-5 project-card slide-in-right"
        >
          <img
            src="src/img/spicyden.svg"
            alt="SpicyDen"
            class="p-5 w-full h-[300px]"
          />
          <h4 class="text-xl font-bold text-primary mb-2">
            SpicyDen – Restaurant App
          </h4>
          <p class="text-white text-sm">
            Built a restaurant application using AngularJS with scalable
            components, implementing testing workflows to ensure high-quality
            code and seamless service management.
          </p>
        </div>
      </div>
    </section>

    <div id="resume" class="flex justify-center items-center my-10 hidden-section">
      <a href="./src/ResumeSE.pdf" download="Saravanan_Resume.pdf">
        <button class="py-4 px-10 rounded-md bg-primary text-white font-bold">
          Download Resume
        </button>
      </a>
    </div>    

    <!-- script tags -->
    <script src="src/app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/swiper@10/swiper-bundle.min.js"></script>
    <script src="src/review.js"></script>

    <script>
      // Scroll Animation Observer
      const observerOptions = {
        root: null,
        rootMargin: '0px',
        threshold: 0.1
      };

      const observer = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
            observer.unobserve(entry.target);
          }
        });
      }, observerOptions);

      // Observe all animated elements
      document.querySelectorAll('.fade-in, .slide-in-left, .slide-in-right, .scale-in, .rotate-in, .project-card, .timeline-item').forEach(element => {
        observer.observe(element);
      });

      // Add 3D effect to project cards
      document.querySelectorAll('.project-card').forEach(card => {
        card.addEventListener('mousemove', (e) => {
          const rect = card.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          
          const rotateX = (y - centerY) / 20;
          const rotateY = (centerX - x) / 20;
          
          card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(10px)`;
        });

        card.addEventListener('mouseleave', () => {
          card.style.transform = 'perspective(1000px) rotateX(0) rotateY(0) translateZ(0)';
        });
      });

      // Add scroll progress indicator
      const progressBar = document.createElement('div');
      progressBar.style.position = 'fixed';
      progressBar.style.top = '0';
      progressBar.style.left = '0';
      progressBar.style.right = '0';
      progressBar.style.height = '3px';
      progressBar.style.background = '#5dadec';
      progressBar.style.transformOrigin = '0%';
      progressBar.style.zIndex = '1000';
      document.body.appendChild(progressBar);

      window.addEventListener('scroll', () => {
        const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
        const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        const scrolled = (winScroll / height) * 100;
        progressBar.style.transform = `scaleX(${scrolled / 100})`;
      });
    </script>
    <script>
    // Ensure hero section is below the fixed header
    function fitHeroBelowHeader() {
      const header = document.querySelector('header');
      const hero = document.getElementById('home');
      if (!header || !hero) return;
      const h = header.getBoundingClientRect().height;
      hero.style.paddingTop = h + 'px';
      hero.style.height = `calc(100vh - ${h}px)`;
    }
    window.addEventListener('DOMContentLoaded', fitHeroBelowHeader);
    window.addEventListener('resize', fitHeroBelowHeader);
    </script>
    
    <script>
    // Reveal hidden sections on scroll
    window.addEventListener('scroll', () => {
      if (window.scrollY > 0) {
        document.querySelectorAll('.hidden-section').forEach(el => {
          el.classList.remove('hidden-section');
          el.classList.add('fade-in-section');
        });
      }
    });
    </script>
    
    <script>
      // Initialize typing animations
      document.addEventListener('DOMContentLoaded', function() {
        // Name typing
        new Typed('#name-typing', {
          strings: ['Saravanan Hari Baskaran'],
          typeSpeed: 50,
          showCursor: true,
          cursorChar: '|',
          autoInsertCss: true,
          onComplete: function(self) {
            self.cursor.remove();
          }
        });

        // Description typing
        new Typed('#description-typing', {
          strings: ['Turning insights into action with a touch of tech magic...'],
          typeSpeed: 30,
          startDelay: 2000,
          showCursor: true,
          cursorChar: '|',
          autoInsertCss: true,
          onComplete: function(self) {
            self.cursor.remove();
          }
        });

        // Work Experience heading typing (triggered on scroll, but only after user scrolls)
        let workTypingStarted = false;
        let observerActivated = false;
        const workHeading = document.getElementById('work-typing');
        const timelineSection = document.getElementById('Timeline');
        let workObserver = null;
        function activateWorkObserver() {
          if (observerActivated || !workHeading || !timelineSection) return;
          observerActivated = true;
          workObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
              if (entry.isIntersecting && !workTypingStarted) {
                workTypingStarted = true;
                new Typed('#work-typing', {
                  strings: ['Work <span class="text-primary">Experience</span>'],
                  typeSpeed: 40,
                  showCursor: true,
                  cursorChar: '|',
                  autoInsertCss: true,
                  onComplete: function(self) {
                    self.cursor.remove();
                  }
                });
                observer.unobserve(entry.target);
              }
            });
          }, { threshold: 0.2 });
          workObserver.observe(workHeading);
        }
        window.addEventListener('scroll', function onFirstScroll() {
          activateWorkObserver();
          window.removeEventListener('scroll', onFirstScroll);
        });
      });
    </script>
  </body>
</html>
